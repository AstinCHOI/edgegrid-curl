#!/usr/bin/env python
#
# Copyright 2013 Akamai Technologies, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import argparse
import os
import sys
import logging
import re
from pprint import pformat
from urlparse import urlparse

# data handling
# only handles -d/--data/--data-ascii/--data-binary
# no name
# only one entry, no repeats
# can handle @

logging.basicConfig()
log = logging.getLogger(__name__)

class MockRequest:
    def __init__(self, data_ascii, data_binary, headers, method, url):
        self.body = self.get_data(data_ascii, data_binary)
        log.info("body: %s", self.body)
        self.headers= headers or {}
        self.method = method
        self.url = url

    def get_data(self, data_ascii, data_binary):
        data = ''
        if data_ascii:
            data = data_ascii
        elif data_binary:
            data = data_binary
        # only hash POST for now
        if data and data.startswith("@"):
            data_file = data.lstrip("@")
            try:
                if not os.path.isfile(data_file):
                    raise Exception('%s is not a file' %(data_file))
                filesize = os.stat(data_file).st_size
                # read the file content, and assign to data
                with open(data_file, "r") as f:
                    data = f.read()
                    if data_ascii:
                        data = ''.join(data.splitlines())
                    return data
            except IOError:
                raise

    def register_hook(self, ignoredA, ignoredB):
        return

def get_host(url, headers):
    return urlparse(url).netloc.split(":")[0].lower()

def _parse_fields(config, line, fields):
    for field in fields:
      log.debug("Config Field: [%s]", field)

      match = re.match("^([^:]+):(.+)$", field)
      if not match:
          log.error("Config line: [%s] has invalid field [%s].", line, field)
          return

      key = match.group(1)
      value = match.group(2)
      log.debug("Config Key: [%s] Value: [%s]", key, value)

      if key not in config.keys():
          log.error("Config line: [%s] has nonexistent variable [%s].", line, key)
          return

      if type(config[key]) == list:
          config[key].append(value)
      elif not config[key]:
          config[key] = value
      else:
          log.error("Config line: [%s] has duplicate variable [%s].", line, key)
          break

def get_parser():
  parser = argparse.ArgumentParser(description='Akamai {OPEN} API utility for signed API requests with cURL.',
                                  epilog='Several arguments above as well as any unlisted arguments are passed on to curl. The <url> argument should always be the final argument.')
  parser.add_argument('-H', '--header',
                      action='append',
                      default = [],
                      help='HTTP headers to pass on to cURL (repeatable)')
  parser.add_argument("--eg-config",
                      default=os.environ["HOME"] + "/.egcurl",
                      help='Location of configuration ini file.')
  parser.add_argument("--eg-section",
                      default = "default",
                      help='Section of the config file for the desired OPEN API credentials.')
  parser.add_argument('--eg-verbose',
                      default=False,
                      help='Enable verbose logging output',
                      action='store_true')
  group = parser.add_mutually_exclusive_group()
  group.add_argument('-d', '--data', '--data-ascii',
                      help='ASCII data content for POST body')
  group.add_argument('--data-binary',
                      help='binary data content for POST body')
  parser.add_argument('-X', '--method',
                      choices=['DELETE', 'GET', 'POST', 'PUT'],
                      help='HTTP method for the request',
                      default='GET')
  parser.add_argument('url',
                      help='Request URL')
  (args, args_unknown) = parser.parse_known_args()
  if args.eg_verbose:
    log.setLevel(logging.DEBUG)

  log.info('Parsed known arguments: %s', pformat(args))
  log.debug('Pass-through cURL arguments: %s', pformat(args_unknown))

  disallowed_parser = argparse.ArgumentParser()
  disallowed_parser.add_argument("-F")
  disallowed_parser.add_argument("--form")
  disallowed_parser.add_argument("--form-string")
  disallowed_parser.add_argument("--data-urlencode")
  disallowed_parser.add_argument("-G", "--get", default=None, action='store_true')
  (args_bad, args_remainder)  = disallowed_parser.parse_known_args(args_unknown)

  unacceptable = []
  for (key, val) in vars(args_bad).items():
    if val != None:
      unacceptable.append(key)

  if len(unacceptable) != 0:
    log.debug('Disallowed cURL arguments: %s', pformat(args_bad))
    parser.error("Unsupported cURL arguments found: " + ', '.join(unacceptable))

  return (args, args_unknown)

def main():
  (args, args_unknown) = get_parser()

  config = args.eg_config
  section = args.eg_section
  method = args.method
  data_ascii = args.data
  data_binary = args.data_binary
  url = args.url

  headers = {}
  if args.header:
    for header in args.header:
      header_field = header.strip()
      header_name, header_value = header_field.split(':')
      if header_name:
        header_name = header_name.strip()
      if not header_name:
        log.error("Invalid header value: %s", header_name)
        sys.exit(1)
      if header_value:
        header_value = header_value.strip()
        if header_value:
          headers[header_name.lower()] = header_value

  host = get_host(url, headers)

  with open(config, "r") as f:
    current_section = None
    config = {}
    matched = False
    for line in f.readlines():
      if re.match("^\\s*($|#|;)", line): continue
      m = re.match("^\\s*\\[(.+?)\\]\\s*$", line)

      if m:
          current_section = m.group(1)
          continue

      config = { "host": 0,
              "client_token": None,
              "access_token": None,
              "secret": None,
              "max-body": None,
              "signed-header": []}
      fields = line.split()
      _parse_fields(config, line, fields)
      if config["max-body"]:
        config["max-body"] = int(config["max-body"])

      if 0 not in config.itervalues():
            if current_section == section:
                p = host.find(config["host"])
                if p == 0:
                    log.debug("Matched line for host %s", host)
                    matched = True
                    break
                pass
            continue
      raise ValueError("could not parse config line: " + line)

    if not matched:
      raise ValueError("could not find applicable config for host: " + host)

    if not config['host']:
      raise ValueError("cannot find matching host")
    if not config['client_token']:
      raise ValueError("client_token is not configured")
    if not config['access_token']:
      raise ValueError("access_token is not configured")
    if not config['secret']:
      raise ValueError("secret is not configured")

    # update the args with the signature
    log.info("Authorization values: %s", pformat(config))

    auth = EdgeGridAuth(
      access_token=config['access_token'],
      client_secret=config['secret'],
      client_token=config['client_token'],
      headers_to_sign=config['signed-header'],
      max_body=config['max-body']
    )

    r = MockRequest(data_ascii, data_binary, headers, method, url)
    auth(r)
    auth_header = r.headers['Authorization']
    log.info("Authorization header: %s", auth_header)

    curl_args = ([ 'curl', '-X', method, '-H', 'Authorization:' + auth_header, '-H', 'Expect:' ])
    for header in args.header:
      curl_args.extend([ '-H', header ])
    if args.data:
      curl_args.extend([ '--data', args.data ])
    if args.data_binary:
      curl_args.extend([ '--data-binary', args.data_binary ])
    curl_args.extend(args_unknown + [ url ])

    log.info("cURL arguments: %s", pformat(curl_args))
    sys.stdout.flush()

    os.execvp(curl_args[0], curl_args)

if __name__ == "__main__":
    if not 'akamai' in sys.modules:
        print("""
This tool has been updated to use the Akamai EdgeGrid for Python library
to sign requests. That library will need to be installed before you can
make a request.

Please run this command to install the required library:

pip install edgegrid-python""")
        sys.exit(1)
    from akamai.edgegrid import EdgeGridAuth
    sys.exit(main())
